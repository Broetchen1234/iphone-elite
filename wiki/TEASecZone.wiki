#summary TEA SecZone decryptor

= Introduction =

This is a decryptor for areas of your iPhone seczone. 


= Details =

{{{
/*
 * teasz - TEA seczone utility
 *
 * Written my MuscleNerd, with lots of help from wikipedia :)
 *
 * Thanks to everyone at iphone-elite.org wiki and IRC channel
 * for providing a more friendly environment in which to participate.
 *
 * The SHA-1 hash value you need to supply is the first 16 bytes of the 
 * 20-byte SHA-1 hash of these 32 bytes:  norID, 8 zeros, HWID, 4 zeros
 *
 * Core TEA algorithm at http://en.wikipedia.org/wiki/Tiny_Encryption_Algorithm
 *  TEA key is 16 bytes/128 bits, TEA block is 8 bytes/64 bits
 * iPhone uses TEA in CBC mode to encrypt/decrypt seczone areas
 */

void encrypt(unsigned long* in, unsigned long* k, unsigned long* out) {
  unsigned long v0, v1, sum, i, delta, k0, k1, k2, k3;
  delta=0X9E3779B9;                       /* a key schedule constant */
  k0=k[0]; k1=k[1]; k2=k[2]; k3=k[3];     /* cache key */
  v0 = in[0]; v1 = in[1]; sum=0;          /* set up */

  for (i=0; i < 32; i++) {                /* basic cycle start */
    sum += delta;
    v0 += ((v1<<4) + k0) ^ (v1 + sum) ^ ((v1>>5) + k1);
    v1 += ((v0<<4) + k2) ^ (v0 + sum) ^ ((v0>>5) + k3); /* end cycle */
  }
  out[0]=v0; out[1]=v1;
}
/* To do: encrypt_cbc() */

void decrypt(unsigned long* v, unsigned long* k) {
  unsigned long v0, v1, sum, i, delta, k0, k1, k2, k3;
  delta=0X9E3779B9;                       /* a key schedule constant */
  k0=k[0]; k1=k[1]; k2=k[2]; k3=k[3];     /* cache key */
  v0 = v[0]; v1 = v[1]; sum=0xC6EF3720;   /* set up */

  for (i=0; i<32; i++) {                               /* basic cycle start */
    v1 -= ((v0<<4) + k2) ^ (v0 + sum) ^ ((v0>>5) + k3);
    v0 -= ((v1<<4) + k0) ^ (v1 + sum) ^ ((v1>>5) + k1);
    sum -= delta;                                      /* end cycle */
  }
  v[0]=v0; v[1]=v1;
}

/* See http://upload.wikimedia.org/wikipedia/en/6/66/Cbc_decryption.png 
   for a depiction of general CBC decryption */
void decrypt_cbc(unsigned long *in, unsigned long len, unsigned long *key, unsigned long *out) {
  unsigned long x[2], nx[2], dec[2], tea[2], offset;

  /* initialization vector */
  /* Note: this is referenced at 0xa02e8320+0x30 by sub_A0234BB8 4.0.1 */
  x[0] = x[1] = 0xffffffff;

  for (offset=0; offset<len; offset+=8) {  /* block size of TEA is 8 bytes */
    int blen = 8;
    if ((len-offset)<8)
      blen = len-offset;

    int i;
    for (i=0; i<(blen>>2); i++)
      tea[i] = in[(offset>>2)+i];

    nx[0]  = tea[0];  nx[1]  = tea[1];  // save these for next CBC round
    decrypt(tea, key);
    dec[0] = tea[0] ^ x[0];
    dec[1] = tea[1] ^ x[1];
    x[0]   = nx[0];   x[1]   = nx[1];
    
    /* Plaintext */
    for (i=0; i<blen; i++)
      ((unsigned char *)out)[offset+i] = ((unsigned char *)dec)[i];
  }
}

int main(int argc, char *argv[]) {
  FILE *f;
  void *ibuf, *buf;
  char *s;
  unsigned long offset, length;
  int i;
  unsigned long sha1hash[5];

  //unsigned long sha1hash[5]   = { 0xaeb0afde,0x93e7528c,0x286e8655,0x023e4617,0x5173825a };
  
  if (argc != 5) {
    fprintf(stderr, "Usage: %s <infile> <offset> <length> <sha>\n", argv[0]);
    return -1;
  }
  if (sscanf(argv[2], "0x%x", &offset)!=1) {
    fprintf(stderr, "please use 0x notation for numbers\n");
    exit(1);
  }
  if (sscanf(argv[3], "0x%x", &length)!=1) {
    fprintf(stderr, "please use 0x notation for numbers\n");
    exit(1);
  }
  s = argv[4];
  if ((strlen(s)!=34) || (strncasecmp(s,"0x", 2)!=0)) {
    fprintf(stderr, "sha must be a 32-character hex string beginning with 0x\n");
    exit(1);
  }
  for (i=0; i<4; i++) {
    char s1[9];
    strncpy(s1,s+2+i*8,8);
    s1[8] = '\0';
    if (sscanf(s1, "%x", &sha1hash[i])!=1) {
      fprintf(stderr, "couldn't parse sha value\n");
      exit(1);
    }
  }

  ibuf = malloc(length); buf = malloc(length);
  if ((f = fopen(argv[1], "rb"))==NULL) {
    perror(argv[1]);
    exit(1);
  }
  if (fseek(f, offset, SEEK_SET)==-1) {
    perror("fseek");
    exit(1);
  }
  if (fread(ibuf, 1, length, f)!=length) {
    perror("fread");
    exit(1);
  }
  fclose(f);

  /* Sorry for this mess... */
  for (i=0; i<length; i++) {
    unsigned char *a;
    unsigned long e;
    a = (unsigned char *)ibuf + i*4;
    e = ((*(a+3))<<24) | ((*(a+2))<<16) | ((*(a+1))<<8) | ((*(a+0))<<0);
    *((unsigned long *)buf+i) = e;
  }

  decrypt_cbc(buf, length, &sha1hash[0], buf);
  fwrite(buf, length, 1, stdout);

  exit(0);
}
}}}

=Example usage=

Here I am using teasz to decrypt the lock tables at offset 0xc88 of my seczone.  Encrypted, it looks like this:
{{{
% dd if=seczone.bin bs=1 skip=0xc88 count=0xe0 2>/dev/null | hexdump -C
00000000  9b 27 43 a9 f3 51 2f da  87 e7 8e f2 6a d1 63 1c  |.'C..Q/.....j.c.|
00000010  3f e7 1e 36 d2 e6 91 d0  6e a7 5d 98 a7 b9 ab e0  |?..6....n.].....|
00000020  c2 70 7e ad 65 35 90 d7  1f 8b 2e 45 8a f7 3e 7d  |.p~.e5.....E..>}|
00000030  95 2b f4 92 06 b1 6c e8  2e 21 5c 0c a7 8b 99 8c  |.+....l..!\.....|
00000040  ac ba 16 35 20 a8 a1 d3  89 d7 c3 42 7a 98 5e b4  |...5 ......Bz.^.|
00000050  50 8f df 0d cf ae 4a ac  e3 91 1a 70 92 31 0c 25  |P.....J....p.1.%|
00000060  0e 9a 72 4a 76 a8 db 5c  aa 8f 55 b7 5d 7d e4 00  |..rJv..\..U.]}..|
00000070  30 75 64 82 af bd fb a7  91 d3 88 52 1a cd ec 18  |0ud........R....|
00000080  a9 ce 40 db 58 6e 59 ad  69 ec 3a e0 ab c2 12 8b  |..@.XnY.i.:.....|
00000090  1f e1 03 ad 22 b9 f3 36  7e 45 f8 43 a6 fb b2 ce  |...."..6~E.C....|
000000a0  cd f9 8e 62 40 fe 9c e2  5e c0 a4 b4 d8 31 39 a4  |...b@...^....19.|
000000b0  33 e6 87 25 15 30 3b e1  32 a3 1f 27 d4 e4 c9 f2  |3..%.0;.2..'....|
000000c0  bb 70 8b 0e bb f3 f2 ad  3a e5 ee 24 85 1a dc 6f  |.p......:..$...o|
000000d0  63 c9 ba 7b 37 53 d1 67  d2 45 d9 20 f9 6d 5a b9  |c..{7S.g.E. .mZ.|
}}}

After passing that through teasz, I get:
% teasz seczone.bin 0xc88 0xe0 $myhash | hexdump -C
{{{
00000000  00 05 01 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000010  00 00 00 00 00 00 00 01  01 05 01 01 00 00 00 00  |................|
00000020  00 00 00 09 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00000040  00 00 05 05 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000050  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000060  00 00 00 00 00 00 00 00  00 00 05 05 00 00 00 00  |................|
00000070  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00000090  00 00 05 05 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000000a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000000b0  00 00 00 00 00 00 00 00  00 00 05 05 00 00 00 00  |................|
000000c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
000000e0
}}}